<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CometFlow – Browser Automation Suite</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --bg: #050914;
      --bg-card: #0f172a;
      --accent: #22d3ee;
      --accent-soft: rgba(34,211,238,0.15);
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --danger: #f97373;
      --success: #22c55e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1f2937 0, #020617 45%, #000 100%);
      color: var(--text-main);
    }
    header {
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(148,163,184,0.2);
      background: linear-gradient(to right, #020617, #0f172a);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    h1 { font-size: 1.3rem; margin: 0; }
    .badge {
      border-radius: 999px;
      padding: 2px 10px;
      font-size: 0.7rem;
      background: var(--accent-soft);
      border: 1px solid rgba(34,211,238,0.4);
      color: var(--accent);
      margin-left: 8px;
    }
    button {
      padding: 7px 12px;
      border-radius: 999px;
      border: none;
      font-weight: 600;
      font-size: 0.85rem;
      cursor: pointer;
      background: var(--accent);
      color: #020617;
    }
    button.secondary {
      background: transparent;
      border: 1px solid rgba(148,163,184,0.5);
      color: var(--text-main);
    }
    button.small { padding: 4px 8px; font-size: 0.75rem; }
    .container { padding: 16px; max-width: 1120px; margin: 0 auto 40px; }
    nav {
      display: flex;
      gap: 8px;
      margin: 10px 0 14px;
      flex-wrap: wrap;
    }
    nav button {
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 0.8rem;
      background: #020617;
      border: 1px solid rgba(148,163,184,0.4);
      color: var(--text-muted);
    }
    nav button.active {
      background: var(--accent-soft);
      border-color: var(--accent);
      color: var(--accent);
    }
    .card {
      background: var(--bg-card);
      border-radius: 10px;
      padding: 14px;
      margin-bottom: 12px;
      border: 1px solid rgba(148,163,184,0.2);
    }
    .card h2 {
      margin: 0 0 8px;
      font-size: 1rem;
    }
    .card h3 {
      margin: 0 0 8px;
      font-size: 0.9rem;
      color: var(--text-muted);
    }
    input, select, textarea {
      width: 100%;
      padding: 7px 9px;
      border-radius: 8px;
      border: 1px solid rgba(148,163,184,0.4);
      background: #020617;
      color: var(--text-main);
      font-size: 0.85rem;
      margin: 4px 0 8px;
    }
    textarea { min-height: 60px; resize: vertical; }
    label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: .04em;
      color: var(--text-muted);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
      margin-top: 4px;
    }
    th, td {
      padding: 6px 4px;
      border-bottom: 1px solid rgba(30,64,175,0.5);
      text-align: left;
    }
    th { color: var(--text-muted); font-weight: 500; }
    .hidden { display: none; }
    .flex { display: flex; align-items: center; gap: 8px; }
    .flex-between { display: flex; justify-content: space-between; align-items: center; gap: 8px; }
    .pill {
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 0.7rem;
      border: 1px solid rgba(148,163,184,0.5);
      color: var(--text-muted);
    }
    .pill.success { border-color: var(--success); color: var(--success); }
    .pill.error { border-color: var(--danger); color: var(--danger); }
    .pill.info { border-color: var(--accent); color: var(--accent); }
    .grid-3 {
      display: grid;
      grid-template-columns: repeat(auto-fit,minmax(180px,1fr));
      gap: 10px;
    }
    .stat {
      background: radial-gradient(circle at top, rgba(34,211,238,0.16), transparent 50%);
      border-radius: 10px;
      padding: 10px;
      border: 1px solid rgba(148,163,184,0.4);
      font-size: 0.8rem;
    }
    .stat-title { color: var(--text-muted); font-size: 0.7rem; text-transform: uppercase; letter-spacing: .08em; }
    .stat-value { font-size: 1.1rem; font-weight: 600; margin-top: 2px; }
    .status-msg { font-size: 0.8rem; margin-top: 4px; min-height: 18px; }
    .status-msg.error { color: var(--danger); }
    .status-msg.success { color: var(--success); }
    footer {
      text-align: center;
      font-size: 0.7rem;
      color: var(--text-muted);
      padding: 12px;
      border-top: 1px solid rgba(148,163,184,0.2);
    }
    .toggle-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0 8px;
      font-size: 0.8rem;
    }
    .rule-hint {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-bottom: 4px;
    }
  </style>
</head>
<body>

<header>
  <div class="flex">
    <h1>CometFlow</h1>
    <span class="badge">Multi-Account · Social · Monitoring</span>
  </div>
  <div id="userBox">
    <button onclick="googleLogin()">Sign in with Google</button>
  </div>
</header>

<div class="container hidden" id="appShell">
  <nav id="tabs">
    <button onclick="showTab('dashboard')" class="active">Dashboard</button>
    <button onclick="showTab('accounts')">Accounts</button>
    <button onclick="showTab('automations')">Automations</button>
    <button onclick="showTab('monitoring')">Monitoring</button>
    <button onclick="showTab('logs')">Logs</button>
    <button onclick="showTab('billing')">Billing & Settings</button>
  </nav>

  <!-- DASHBOARD -->
  <section id="dashboard" class="tab">
    <div class="card">
      <div class="flex-between">
        <div>
          <h2>Overview</h2>
          <p class="status-msg" id="statusMsg"></p>
        </div>
        <div id="planBadge"></div>
      </div>
      <div class="grid-3" id="statsGrid"></div>
    </div>
    <div class="card">
      <h3>Recent Logs</h3>
      <table id="recentLogsTable"></table>
    </div>
  </section>

  <!-- ACCOUNTS -->
  <section id="accounts" class="tab hidden">
    <div class="card">
      <div class="flex-between">
        <h2>Accounts</h2>
        <div class="flex">
          <span class="pill" id="accountsCount"></span>
          <button class="secondary small" onclick="exportUserData('accounts')">Export Accounts</button>
          <button class="secondary small" onclick="triggerImport('accounts')">Import Accounts</button>
        </div>
      </div>
      <label>Account Name</label>
      <input id="accName" placeholder="e.g. LinkedIn Main Profile">
      <label>Platform</label>
      <select id="accPlatform">
        <option value="LINKEDIN">LinkedIn</option>
        <option value="TWITTER">Twitter / X</option>
        <option value="INSTAGRAM">Instagram</option>
        <option value="CUSTOM">Custom</option>
      </select>
      <button onclick="addAccount()">Add Account</button>
      <div class="status-msg" id="accountsStatus"></div>
    </div>
    <div class="card">
      <h3>Your Accounts</h3>
      <table id="accountsTable"></table>
    </div>
  </section>

  <!-- AUTOMATIONS -->
  <section id="automations" class="tab hidden">
    <div class="card">
      <div class="flex-between">
        <h2>Automations</h2>
        <div class="flex">
          <span class="pill" id="tasksCount"></span>
          <button class="secondary small" onclick="exportUserData('tasks')">Export Tasks</button>
          <button class="secondary small" onclick="triggerImport('tasks')">Import Tasks</button>
        </div>
      </div>
      <div class="flex" style="margin-bottom:6px;">
        <label>Template</label>
        <select id="templateSelect" onchange="applyTemplate()">
          <option value="">Choose template...</option>
          <option value="tw_daily_post">Daily Twitter post</option>
          <option value="ln_morning_post">Morning LinkedIn post</option>
          <option value="price_monitor">Product price monitor</option>
          <option value="content_monitor">Page content watcher</option>
        </select>
      </div>
      <label>Task Name</label>
      <input id="taskName" placeholder="e.g. Daily LinkedIn Morning Post">
      <label>Type</label>
      <select id="taskType">
        <option value="SOCIAL_POST">SOCIAL_POST</option>
        <option value="SOCIAL_ACTION">SOCIAL_ACTION</option>
        <option value="WEB_MONITOR">WEB_MONITOR</option>
      </select>
      <label>Config (JSON)</label>
      <textarea id="taskConfig" placeholder='e.g. {"platform":"TWITTER","text":"Hello!"}'></textarea>
      <label>Schedule</label>
      <select id="taskSchedule">
        <option value="IMMEDIATE">IMMEDIATE</option>
        <option value="EVERY_6_HOURS">EVERY_6_HOURS</option>
        <option value="DAILY">DAILY</option>
      </select>
      <button onclick="addTask()">Create Task</button>
      <div class="status-msg" id="tasksStatus"></div>
    </div>
    <div class="card">
      <h3>Your Tasks</h3>
      <table id="tasksTable"></table>
    </div>
  </section>

  <!-- MONITORING -->
  <section id="monitoring" class="tab hidden">
    <div class="card">
      <div class="flex-between">
        <h2>Monitoring</h2>
        <div class="flex">
          <span class="pill" id="monitorsCount"></span>
          <button class="secondary small" onclick="exportUserData('monitors')">Export Monitors</button>
          <button class="secondary small" onclick="triggerImport('monitors')">Import Monitors</button>
        </div>
      </div>

      <label>URL</label>
      <input id="monUrl" placeholder="https://example.com/product">

      <label>CSS Selector</label>
      <input id="monSelector" placeholder=".price, .headline, .item-card, etc.">

      <label>Rule Type</label>
      <select id="monRuleType" onchange="onRuleTypeChange()">
        <option value="TEXT_CHANGE">Text changes</option>
        <option value="PRICE_BELOW">Price drops below value</option>
        <option value="COUNT_CHANGE">Number of elements changes</option>
      </select>
      <div class="rule-hint" id="ruleHint">
        Text changes: trigger when the selected text content changes compared to last value.
      </div>

      <div id="priceRuleFields" class="hidden">
        <label>Price Threshold</label>
        <input id="monPriceThreshold" type="number" step="0.01" placeholder="e.g. 499.00">
        <div class="rule-hint">
          The rule will trigger the first time the price goes from above this value to below it.
        </div>
      </div>

      <div id="countRuleFields" class="hidden">
        <label>Count Change Mode</label>
        <select id="monCountMode">
          <option value="ANY_CHANGE">Any change</option>
          <option value="INCREASE">Only if count increases</option>
          <option value="DECREASE">Only if count decreases</option>
        </select>
        <div class="rule-hint">
          Example: use a selector that matches listing cards. The rule can trigger when new items appear or disappear.
        </div>
      </div>

      <button onclick="addMonitor()">Add Monitor</button>
      <div class="status-msg" id="monitorsStatus"></div>
    </div>

    <div class="card">
      <h3>Your Monitors</h3>
      <table id="monitorTable"></table>
    </div>
  </section>

  <!-- LOGS -->
  <section id="logs" class="tab hidden">
    <div class="card">
      <div class="flex-between">
        <h2>Execution Logs</h2>
        <div class="flex">
          <button class="secondary small" onclick="exportUserData('logs')">Export Logs</button>
        </div>
      </div>
      <table id="logsTable"></table>
    </div>
  </section>

  <!-- BILLING / SETTINGS -->
  <section id="billing" class="tab hidden">
    <div class="card">
      <h2>Plan & Limits</h2>
      <p style="font-size:0.8rem;color:var(--text-muted);">
        Plans are enforced client-side for now so you can test limits before adding real billing.
      </p>
      <div class="grid-3">
        <div class="stat">
          <div class="stat-title">Free</div>
          <div class="stat-value">FREE</div>
          <ul style="font-size:0.75rem; padding-left:16px;">
            <li>1 Account</li>
            <li>3 Tasks</li>
            <li>3 Monitors</li>
          </ul>
          <button class="small secondary" onclick="setPlan('FREE')">Select</button>
        </div>
        <div class="stat">
          <div class="stat-title">Basic</div>
          <div class="stat-value">$4.99</div>
          <ul style="font-size:0.75rem; padding-left:16px;">
            <li>3 Accounts</li>
            <li>20 Tasks</li>
            <li>10 Monitors</li>
          </ul>
          <button class="small secondary" onclick="setPlan('BASIC')">Select</button>
        </div>
        <div class="stat">
          <div class="stat-title">Pro</div>
          <div class="stat-value">$9.99</div>
          <ul style="font-size:0.75rem; padding-left:16px;">
            <li>10 Accounts</li>
            <li>100 Tasks</li>
            <li>50 Monitors</li>
          </ul>
          <button class="small secondary" onclick="setPlan('PRO')">Select</button>
        </div>
      </div>
      <div class="status-msg" id="billingStatus"></div>
    </div>

    <div class="card">
      <h2>Notifications</h2>
      <p style="font-size:0.8rem;color:var(--text-muted);">
        These settings are stored in your profile. The Firebase Cloud Function reads them and sends real
        Email, Telegram, or Webhook notifications whenever a new log is created.
      </p>
      <div class="toggle-row">
        <input type="checkbox" id="notifyEmail">
        <span>Enable email notifications (to your login email)</span>
      </div>
      <div class="toggle-row">
        <input type="checkbox" id="notifyTelegram">
        <span>Enable Telegram notifications</span>
      </div>
      <label>Telegram Chat ID</label>
      <input id="telegramChatId" placeholder="Your Telegram chat ID (from your bot)">
      <div class="toggle-row">
        <input type="checkbox" id="notifyWebhook">
        <span>Enable Webhook notifications</span>
      </div>
      <label>Webhook URL</label>
      <input id="webhookUrl" placeholder="https://your-server.com/cometflow-webhook">
      <button class="small" onclick="saveNotificationSettings()">Save Notification Settings</button>
      <div class="status-msg" id="notificationsStatus"></div>
    </div>
  </section>
</div>

<footer>
  CometFlow · Firebase + GitHub Pages MVP · Smart monitoring rules enabled
</footer>

<!-- Firebase v8 -->
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

<script>
// 1) FIREBASE CONFIG – replace values with your real config from Firebase Console
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyAYDhqY88uclZN2UMleOY0Dbg6-07e2Q2Y",
  authDomain: "cometflow-app.firebaseapp.com",
  projectId: "cometflow-app",
  storageBucket: "cometflow-app.firebasestorage.app",
  messagingSenderId: "693582343294",
  appId: "1:693582343294:web:92850989124e30fda1bc2f",
  measurementId: "G-3FGVHBX07D"
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db   = firebase.firestore();

let UID = null;
let currentUserDoc = null;

// Plan limits
const PLAN_LIMITS = {
  FREE:  { maxAccounts: 1,  maxTasks: 3,   maxMonitors: 3 },
  BASIC: { maxAccounts: 3,  maxTasks: 20,  maxMonitors: 10 },
  PRO:   { maxAccounts: 10, maxTasks: 100, maxMonitors: 50 },
};

function googleLogin() {
  auth.signInWithPopup(new firebase.auth.GoogleAuthProvider());
}
function logout() {
  auth.signOut();
}

// Tabs
function showTab(id) {
  document.querySelectorAll(".tab").forEach(t => t.classList.add("hidden"));
  document.getElementById(id).classList.remove("hidden");

  document.querySelectorAll("nav button").forEach(btn => btn.classList.remove("active"));
  const btn = Array.from(document.querySelectorAll("nav button"))
    .find(b => b.textContent.toLowerCase().includes(id.slice(0,3)));
  if (btn) btn.classList.add("active");
}

auth.onAuthStateChanged(async (user) => {
  if (!user) {
    UID = null;
    document.getElementById("userBox").innerHTML =
      '<button onclick="googleLogin()">Sign in with Google</button>';
    document.getElementById("appShell").classList.add("hidden");
    return;
  }
  UID = user.uid;
  document.getElementById("userBox").innerHTML =
    `<span style="font-size:0.8rem;margin-right:8px;">${user.email}</span>
     <button class="secondary small" onclick="logout()">Logout</button>`;

  document.getElementById("appShell").classList.remove("hidden");
  await ensureUserProfile(user);
  await loadAllData();
  showTab('dashboard');
});

// Ensure user profile
async function ensureUserProfile(user) {
  const ref = db.collection("users").doc(user.uid);
  const snap = await ref.get();
  if (!snap.exists) {
    const data = {
      uid: user.uid,
      email: user.email,
      plan: "FREE",
      notifyEmail: false,
      notifyTelegram: false,
      notifyWebhook: false,
      telegramChatId: "",
      webhookUrl: "",
      created: Date.now()
    };
    await ref.set(data);
    currentUserDoc = data;
  } else {
    currentUserDoc = snap.data();
    if (currentUserDoc.notifyEmail === undefined) currentUserDoc.notifyEmail = false;
    if (currentUserDoc.notifyTelegram === undefined) currentUserDoc.notifyTelegram = false;
    if (currentUserDoc.notifyWebhook === undefined) currentUserDoc.notifyWebhook = false;
    if (currentUserDoc.telegramChatId === undefined) currentUserDoc.telegramChatId = "";
    if (currentUserDoc.webhookUrl === undefined) currentUserDoc.webhookUrl = "";
  }
  renderPlanBadge();
  renderNotificationSettings();
}

async function setPlan(plan) {
  if (!UID) return;
  await db.collection("users").doc(UID).update({ plan });
  currentUserDoc.plan = plan;
  renderPlanBadge();
  document.getElementById("billingStatus").textContent =
    `Plan updated to ${plan}. Limits now enforced in UI.`;
}

function renderPlanBadge() {
  const plan = currentUserDoc?.plan || "FREE";
  const badgeEl = document.getElementById("planBadge");
  const limits = PLAN_LIMITS[plan];
  badgeEl.innerHTML =
    `<span class="pill info">Plan: ${plan}</span>
     <span class="pill">Acc ${limits.maxAccounts} · Tasks ${limits.maxTasks} · Mon ${limits.maxMonitors}</span>`;
}

function renderNotificationSettings() {
  if (!currentUserDoc) return;
  document.getElementById("notifyEmail").checked   = !!currentUserDoc.notifyEmail;
  document.getElementById("notifyTelegram").checked= !!currentUserDoc.notifyTelegram;
  document.getElementById("notifyWebhook").checked = !!currentUserDoc.notifyWebhook;
  document.getElementById("telegramChatId").value  = currentUserDoc.telegramChatId || "";
  document.getElementById("webhookUrl").value      = currentUserDoc.webhookUrl || "";
}

async function saveNotificationSettings() {
  if (!UID) return;
  const notifyEmail    = document.getElementById("notifyEmail").checked;
  const notifyTelegram = document.getElementById("notifyTelegram").checked;
  const notifyWebhook  = document.getElementById("notifyWebhook").checked;
  const telegramChatId = document.getElementById("telegramChatId").value.trim();
  const webhookUrl     = document.getElementById("webhookUrl").value.trim();

  await db.collection("users").doc(UID).update({
    notifyEmail,
    notifyTelegram,
    notifyWebhook,
    telegramChatId,
    webhookUrl
  });

  currentUserDoc.notifyEmail = notifyEmail;
  currentUserDoc.notifyTelegram = notifyTelegram;
  currentUserDoc.notifyWebhook = notifyWebhook;
  currentUserDoc.telegramChatId = telegramChatId;
  currentUserDoc.webhookUrl = webhookUrl;

  const msgEl = document.getElementById("notificationsStatus");
  msgEl.className = "status-msg success";
  msgEl.textContent = "Notification settings saved.";
}

// Load data
async function loadAllData() {
  if (!UID) return;

  const [accSnap, taskSnap, monSnap, logSnap] = await Promise.all([
    db.collection("accounts").where("uid","==",UID).get(),
    db.collection("tasks").where("uid","==",UID).get(),
    db.collection("monitors").where("uid","==",UID).get(),
    db.collection("logs").where("uid","==",UID)
      .orderBy("created","desc").limit(50).get()
  ]);

  renderStats(accSnap.size, taskSnap.size, monSnap.size, logSnap.size);
  renderAccounts(accSnap);
  renderTasks(taskSnap);
  renderMonitors(monSnap);
  renderLogs(logSnap);
  renderRecentLogs(logSnap);
}

function renderStats(accCount, taskCount, monCount, logCount) {
  const statsEl = document.getElementById("statsGrid");
  statsEl.innerHTML = `
    <div class="stat">
      <div class="stat-title">Accounts</div>
      <div class="stat-value">${accCount}</div>
    </div>
    <div class="stat">
      <div class="stat-title">Tasks</div>
      <div class="stat-value">${taskCount}</div>
    </div>
    <div class="stat">
      <div class="stat-title">Monitors</div>
      <div class="stat-value">${monCount}</div>
    </div>
    <div class="stat">
      <div class="stat-title">Logs</div>
      <div class="stat-value">${logCount}</div>
    </div>
  `;
  document.getElementById("accountsCount").textContent = `${accCount} accounts`;
  document.getElementById("tasksCount").textContent    = `${taskCount} tasks`;
  document.getElementById("monitorsCount").textContent = `${monCount} monitors`;
}

// Accounts
async function addAccount() {
  if (!UID) return;
  const plan = currentUserDoc?.plan || "FREE";
  const limits = PLAN_LIMITS[plan];

  const accSnap = await db.collection("accounts").where("uid","==",UID).get();
  if (accSnap.size >= limits.maxAccounts) {
    const s = document.getElementById("accountsStatus");
    s.className = "status-msg error";
    s.textContent = `Plan ${plan} limit reached (${limits.maxAccounts} accounts).`;
    return;
  }

  const name = document.getElementById("accName").value.trim();
  const platform = document.getElementById("accPlatform").value;
  if (!name) {
    const s = document.getElementById("accountsStatus");
    s.className = "status-msg error";
    s.textContent = "Account name is required.";
    return;
  }
  await db.collection("accounts").add({
    uid: UID,
    name,
    platform,
    created: Date.now()
  });
  document.getElementById("accName").value = "";
  const s = document.getElementById("accountsStatus");
  s.className = "status-msg success";
  s.textContent = "Account added.";
  await loadAllData();
}

function renderAccounts(qs) {
  let html = "<tr><th>Name</th><th>Platform</th><th>Created</th></tr>";
  qs.forEach(d => {
    const x = d.data();
    html += `<tr>
      <td>${x.name}</td>
      <td>${x.platform}</td>
      <td>${x.created ? new Date(x.created).toLocaleString() : ""}</td>
    </tr>`;
  });
  document.getElementById("accountsTable").innerHTML = html;
}

// Templates
function applyTemplate() {
  const value = document.getElementById("templateSelect").value;
  if (!value) return;

  const nameEl = document.getElementById("taskName");
  const typeEl = document.getElementById("taskType");
  const confEl = document.getElementById("taskConfig");
  const schedEl= document.getElementById("taskSchedule");

  if (value === "tw_daily_post") {
    nameEl.value = "Daily Twitter post";
    typeEl.value = "SOCIAL_POST";
    confEl.value = JSON.stringify({
      platform: "TWITTER",
      url: "https://twitter.com/compose/tweet",
      text: "Good morning from CometFlow!",
      accountId: null
    }, null, 2);
    schedEl.value = "DAILY";
  } else if (value === "ln_morning_post") {
    nameEl.value = "Morning LinkedIn post";
    typeEl.value = "SOCIAL_POST";
    confEl.value = JSON.stringify({
      platform: "LINKEDIN",
      url: "https://www.linkedin.com/feed/",
      text: "Starting the day with CometFlow automation.",
      accountId: null
    }, null, 2);
    schedEl.value = "DAILY";
  } else if (value === "price_monitor") {
    nameEl.value = "Price monitor";
    typeEl.value = "WEB_MONITOR";
    confEl.value = JSON.stringify({
      url: "https://example.com/product",
      selector: ".price",
      monitorType: "PRICE_CHANGE"
    }, null, 2);
    schedEl.value = "EVERY_6_HOURS";
  } else if (value === "content_monitor") {
    nameEl.value = "Content change watcher";
    typeEl.value = "WEB_MONITOR";
    confEl.value = JSON.stringify({
      url: "https://example.com/blog",
      selector: "article h1",
      monitorType: "CONTENT_CHANGE"
    }, null, 2);
    schedEl.value = "EVERY_6_HOURS";
  }
}

// Tasks
async function addTask() {
  if (!UID) return;
  const plan = currentUserDoc?.plan || "FREE";
  const limits = PLAN_LIMITS[plan];

  const taskSnap = await db.collection("tasks").where("uid","==",UID).get();
  if (taskSnap.size >= limits.maxTasks) {
    const s = document.getElementById("tasksStatus");
    s.className = "status-msg error";
    s.textContent = `Plan ${plan} limit reached (${limits.maxTasks} tasks).`;
    return;
  }

  const name = document.getElementById("taskName").value.trim();
  const type = document.getElementById("taskType").value;
  const configStr = document.getElementById("taskConfig").value.trim();
  const schedule = document.getElementById("taskSchedule").value;

  if (!name || !configStr) {
    const s = document.getElementById("tasksStatus");
    s.className = "status-msg error";
    s.textContent = "Task name and config are required.";
    return;
  }

  let cfg;
  try {
    cfg = JSON.parse(configStr);
  } catch(e) {
    const s = document.getElementById("tasksStatus");
    s.className = "status-msg error";
    s.textContent = "Config must be valid JSON.";
    return;
  }

  await db.collection("tasks").add({
    uid: UID,
    name,
    type,
    config: cfg,
    schedule,
    enabled: true,
    lastRunAt: null,
    created: Date.now()
  });
  const s = document.getElementById("tasksStatus");
  s.className = "status-msg success";
  s.textContent = "Task created.";
  document.getElementById("taskName").value = "";
  await loadAllData();
}

function renderTasks(qs) {
  let html = "<tr><th>Name</th><th>Type</th><th>Schedule</th><th>Last Run</th></tr>";
  qs.forEach(d => {
    const x = d.data();
    html += `<tr>
      <td>${x.name}</td>
      <td>${x.type}</td>
      <td>${x.schedule || ""}</td>
      <td>${x.lastRunAt ? new Date(x.lastRunAt).toLocaleString() : "-"}</td>
    </tr>`;
  });
  document.getElementById("tasksTable").innerHTML = html;
}

// Monitoring UI rule hint
function onRuleTypeChange() {
  const v = document.getElementById("monRuleType").value;
  const hint = document.getElementById("ruleHint");
  const priceFields = document.getElementById("priceRuleFields");
  const countFields = document.getElementById("countRuleFields");

  priceFields.classList.add("hidden");
  countFields.classList.add("hidden");

  if (v === "TEXT_CHANGE") {
    hint.textContent = "Text changes: trigger when the selected text content changes compared to last value.";
  } else if (v === "PRICE_BELOW") {
    hint.textContent = "Price drops: trigger when the extracted price goes below your threshold.";
    priceFields.classList.remove("hidden");
  } else if (v === "COUNT_CHANGE") {
    hint.textContent = "Count changes: trigger when the number of elements matching the selector changes.";
    countFields.classList.remove("hidden");
  }
}
onRuleTypeChange();

// Monitors
async function addMonitor() {
  if (!UID) return;
  const plan = currentUserDoc?.plan || "FREE";
  const limits = PLAN_LIMITS[plan];

  const monSnap = await db.collection("monitors").where("uid","==",UID).get();
  if (monSnap.size >= limits.maxMonitors) {
    const s = document.getElementById("monitorsStatus");
    s.className = "status-msg error";
    s.textContent = `Plan ${plan} limit reached (${limits.maxMonitors} monitors).`;
    return;
  }

  const url = document.getElementById("monUrl").value.trim();
  const selector = document.getElementById("monSelector").value.trim();
  const ruleType = document.getElementById("monRuleType").value;
  const priceThresholdStr = document.getElementById("monPriceThreshold").value.trim();
  const countMode = document.getElementById("monCountMode").value;

  if (!url) {
    const s = document.getElementById("monitorsStatus");
    s.className = "status-msg error";
    s.textContent = "URL is required.";
    return;
  }

  let type = "CONTENT_CHANGE";
  if (ruleType === "PRICE_BELOW") type = "PRICE_CHANGE";
  if (ruleType === "COUNT_CHANGE") type = "NEW_ITEM";

  let ruleThreshold = null;
  if (ruleType === "PRICE_BELOW" && priceThresholdStr) {
    const v = parseFloat(priceThresholdStr);
    if (!isNaN(v)) ruleThreshold = v;
  }

  const monitorDoc = {
    uid: UID,
    url,
    type,               // conceptual type
    selector,
    ruleType,           // real rule engine type
    ruleThreshold,      // number or null
    ruleDirection: ruleType === "COUNT_CHANGE" ? countMode : null,
    lastValue: null,
    lastCount: null,
    lastCheckedAt: null,
    lastTriggeredAt: null,
    created: Date.now()
  };

  await db.collection("monitors").add(monitorDoc);

  const s = document.getElementById("monitorsStatus");
  s.className = "status-msg success";
  s.textContent = "Monitor added.";
  document.getElementById("monUrl").value = "";
  document.getElementById("monSelector").value = "";
  document.getElementById("monPriceThreshold").value = "";
  await loadAllData();
}

function ruleSummary(mon) {
  const rt = mon.ruleType || inferRuleTypeFromType(mon.type);
  if (rt === "PRICE_BELOW") {
    return `Price below ${mon.ruleThreshold ?? "?"}`;
  }
  if (rt === "COUNT_CHANGE") {
    const dir = mon.ruleDirection || "ANY_CHANGE";
    if (dir === "INCREASE") return "Count increases";
    if (dir === "DECREASE") return "Count decreases";
    return "Count changes";
  }
  return "Text changes";
}

function renderMonitors(qs) {
  let html = "<tr><th>URL</th><th>Selector</th><th>Rule</th><th>Last Value</th><th>Last Check</th></tr>";
  qs.forEach(d => {
    const x = d.data();
    html += `<tr>
      <td style="max-width:220px;word-break:break-all;">${x.url}</td>
      <td>${x.selector || "-"}</td>
      <td>${ruleSummary(x)}</td>
      <td>${x.lastValue ? (""+x.lastValue).slice(0,40) : "-"}</td>
      <td>${x.lastCheckedAt ? new Date(x.lastCheckedAt).toLocaleString() : "-"}</td>
    </tr>`;
  });
  document.getElementById("monitorTable").innerHTML = html;
}

// Logs (with diff info if available)
function renderLogs(qs) {
  let html = "<tr><th>Task/Monitor</th><th>Status</th><th>Message</th><th>Diff</th><th>Time</th></tr>";
  qs.forEach(d => {
    const x = d.data();
    const cls = x.status === "SUCCESS" ? "pill success" : "pill error";
    let diffSnippet = "";
    if (x.raw && (x.raw.oldValue !== undefined || x.raw.newValue !== undefined)) {
      const ov = x.raw.oldValue !== null && x.raw.oldValue !== undefined ? String(x.raw.oldValue) : "";
      const nv = x.raw.newValue !== null && x.raw.newValue !== undefined ? String(x.raw.newValue) : "";
      diffSnippet = `${ov.slice(0,20)} → ${nv.slice(0,20)}`;
    }
    html += `<tr>
      <td>${x.taskName || x.taskId || "-"}</td>
      <td><span class="${cls}">${x.status}</span></td>
      <td>${x.message || ""}</td>
      <td>${diffSnippet}</td>
      <td>${x.created ? new Date(x.created).toLocaleString() : ""}</td>
    </tr>`;
  });
  document.getElementById("logsTable").innerHTML = html;
}

function renderRecentLogs(qs) {
  let html = "<tr><th>Task</th><th>Status</th><th>Message</th></tr>";
  let count = 0;
  qs.forEach(d => {
    if (count >= 5) return;
    const x = d.data();
    const cls = x.status === "SUCCESS" ? "pill success" : "pill error";
    html += `<tr>
      <td>${x.taskName || x.taskId || "-"}</td>
      <td><span class="${cls}">${x.status}</span></td>
      <td>${x.message || ""}</td>
    </tr>`;
    count++;
  });
  document.getElementById("recentLogsTable").innerHTML = html;
}

// Export
async function exportUserData(type) {
  if (!UID) return;
  let col = null;
  if (type === "accounts") col = "accounts";
  else if (type === "tasks") col = "tasks";
  else if (type === "monitors") col = "monitors";
  else if (type === "logs") col = "logs";
  if (!col) return;

  const snap = await db.collection(col).where("uid","==",UID).get();
  const arr = [];
  snap.forEach(d => arr.push({ id: d.id, ...d.data() }));

  const blob = new Blob([JSON.stringify(arr, null, 2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `cometflow_${col}_${new Date().toISOString().slice(0,10)}.json`;
  a.click();
  URL.revokeObjectURL(url);
}

// Import
let importTarget = null;
function triggerImport(type) {
  importTarget = type;
  const input = document.createElement("input");
  input.type = "file";
  input.accept = "application/json";
  input.onchange = (e) => handleImportFile(e.target.files[0], type);
  input.click();
}

async function handleImportFile(file, type) {
  if (!file || !UID) return;
  const text = await file.text();
  let data;
  try {
    data = JSON.parse(text);
  } catch {
    alert("Invalid JSON file.");
    return;
  }
  if (!Array.isArray(data)) {
    alert("JSON must be an array of docs.");
    return;
  }

  const batch = db.batch();
  const colName = type;
  const colRef = db.collection(colName);

  data.forEach(doc => {
    const ref = colRef.doc();
    const { id, uid, ...rest } = doc;
    batch.set(ref, {
      ...rest,
      uid: UID,
      created: rest.created || Date.now()
    });
  });

  await batch.commit();
  await loadAllData();
  alert(`Imported ${data.length} items into ${type}.`);
}

// ---- Rule evaluation helpers (to reuse in worker/backend) ----
function parsePriceToNumber(text) {
  if (!text) return null;
  let cleaned = String(text)
    .replace(/[^0-9.,\-]/g, '')
    .replace(',', '.');
  const num = parseFloat(cleaned);
  return isNaN(num) ? null : num;
}

function inferRuleTypeFromType(type) {
  if (type === 'PRICE_CHANGE') return 'PRICE_BELOW';
  if (type === 'NEW_ITEM') return 'COUNT_CHANGE';
  return 'TEXT_CHANGE';
}

function evaluateMonitorRule(monitor, currentValue, currentCount) {
  const ruleType = monitor.ruleType || inferRuleTypeFromType(monitor.type);
  const direction = monitor.ruleDirection || 'ANY_CHANGE';
  const threshold = typeof monitor.ruleThreshold === 'number'
    ? monitor.ruleThreshold
    : null;

  const prevValue = monitor.lastValue || null;
  const prevCount = typeof monitor.lastCount === 'number' ? monitor.lastCount : null;

  let triggered = false;
  let reason = 'No change';

  if (ruleType === 'TEXT_CHANGE') {
    if (prevValue === null) {
      triggered = false;
      reason = 'Initial capture';
    } else if (prevValue !== currentValue) {
      triggered = true;
      reason = 'Text changed';
    }
  } else if (ruleType === 'PRICE_BELOW') {
    const currentNum = parsePriceToNumber(currentValue);
    const prevNum = prevValue !== null ? parsePriceToNumber(prevValue) : null;

    if (currentNum === null || threshold === null) {
      triggered = false;
      reason = 'Price or threshold invalid';
    } else if (currentNum < threshold) {
      if (prevNum === null || prevNum >= threshold) {
        triggered = true;
        reason = `Price dropped below ${threshold} (now ${currentNum})`;
      } else {
        triggered = false;
        reason = 'Price already below threshold';
      }
    } else {
      triggered = false;
      reason = `Price above threshold (${currentNum} >= ${threshold})`;
    }
  } else if (ruleType === 'COUNT_CHANGE') {
    const curr = typeof currentCount === 'number' ? currentCount : 0;
    const prev = prevCount === null ? curr : prevCount;
    if (direction === 'ANY_CHANGE') {
      if (prev !== curr) {
        triggered = true;
        reason = `Count changed from ${prev} to ${curr}`;
      }
    } else if (direction === 'INCREASE') {
      if (curr > prev) {
        triggered = true;
        reason = `Count increased from ${prev} to ${curr}`;
      }
    } else if (direction === 'DECREASE') {
      if (curr < prev) {
        triggered = true;
        reason = `Count decreased from ${prev} to ${curr}`;
      }
    }
  } else {
    if (prevValue === null) {
      triggered = false;
      reason = 'Initial capture';
    } else if (prevValue !== currentValue) {
      triggered = true;
      reason = 'Value changed';
    }
  }

  return {
    triggered,
    reason,
    newLastValue: currentValue,
    newLastCount: typeof currentCount === 'number' ? currentCount : prevCount
  };
}
</script>

</body>
</html>
